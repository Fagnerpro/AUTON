‚úÖ 1. Chaves inconsistentes na renderiza√ß√£o de listas
O uso de key={simulationKey} com base em simulation.updatedAt ou createdAt pode ser inst√°vel. Toda vez que o estado muda, isso for√ßa o React a interpretar que o componente √© outro, tentando remover um n√≥ e inserir outro, o que gera o erro se o DOM j√° foi alterado.

Correto:

tsx
Copiar
Editar
key={simulation.id}
‚úÖ 2. Componente Text citado nos erros
Os erros apontam para um componente chamado <Text> que aparentemente est√° envolvido no processo de erro dentro de um bot√£o:

vbnet
Copiar
Editar
The above error occurred in the <Text> component:
üìå Pode ser um componente estilizado ou nativo, e est√° sendo removido ou renderizado antes que seu n√≥ DOM pai esteja pronto, causando erro de reconcilia√ß√£o.

‚úÖ 3. Manipula√ß√£o direta do DOM (removeChild, insertBefore) dentro do downloadFile
A fun√ß√£o de download cria um <a> no DOM e remove posteriormente com:

tsx
Copiar
Editar
document.body.appendChild(link);
...
document.body.removeChild(elementToRemove);
Se o downloadFile for acionado e, antes do timeout, o componente for desmontado (ex: navega√ß√£o ou erro), o n√≥ pode j√° n√£o existir mais.

üõ†Ô∏è Recomenda√ß√µes para corre√ß√£o
üîß 1. Corrija a key de todos os .map() para garantir unicidade e estabilidade
Troque:

tsx
Copiar
Editar
const simulationKey = `simulation-${simulation.id}-${simulation.updatedAt || simulation.createdAt}`;
Por:

tsx
Copiar
Editar
key={simulation.id}
üîß 2. Garanta que downloadFile s√≥ remova o link se ele ainda existir
Substitua:

tsx
Copiar
Editar
if (elementToRemove && elementToRemove.parentNode === document.body) {
  document.body.removeChild(elementToRemove);
}
Por:

tsx
Copiar
Editar
if (elementToRemove && document.body.contains(elementToRemove)) {
  document.body.removeChild(elementToRemove);
}
E evite a remo√ß√£o se o componente foi desmontado:

tsx
Copiar
Editar
if (!isComponentMounted) return;
üîß 3. Adicione key consistente em elementos dinamicamente vis√≠veis
Evite isso:

tsx
Copiar
Editar
{message.type && (
  <div>...</div>
)}
Use:

tsx
Copiar
Editar
{message.type && (
  <div key={`msg-${message.type}`}>...</div>
)}
üîß 4. Certifique-se de que efeitos n√£o alterem o DOM ap√≥s desmontagem
A fun√ß√£o showMessage atual cria setTimeout mas a limpeza n√£o √© chamada corretamente.

Sugest√£o:

tsx
Copiar
Editar
useEffect(() => {
  if (message.type) {
    const timer = setTimeout(() => {
      setMessage({ type: null, text: '' });
    }, 5000);
    return () => clearTimeout(timer);
  }
}, [message]);
üîß 5. Atualize o ErrorBoundary com logs √∫teis e recarregamento opcional
Na sua error-boundary.tsx, registre erros com mais detalhes e ofere√ßa bot√£o de recarregar:

tsx
Copiar
Editar
componentDidCatch(error: Error, info: ErrorInfo) {
  console.error('Erro capturado pelo ErrorBoundary:', error, info);
  this.setState({ hasError: true });
}
‚úÖ Conclus√£o
Esses erros s√£o t√≠picos de inconsist√™ncia entre a √°rvore DOM real e a virtual ‚Äî geralmente causados por:

Chaves vol√°teis

Manipula√ß√£o manual de DOM sem prote√ß√£o

Efeitos de tempo (setTimeout) que agem ap√≥s desmontagem